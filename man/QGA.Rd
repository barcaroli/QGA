% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/QGA.R
\name{QGA}
\alias{QGA}
\title{Quantum Genetic Algorithm}
\usage{
QGA(
  popsize = 20,
  generation_max = 200,
  nvalues_sol,
  Genome,
  thetainit = 3.1415926535 * 0.05,
  thetaend = 3.1415926535 * 0.025,
  pop_mutation_rate_max = 1/(popsize + 1),
  pop_mutation_rate_min = 1/(popsize + 1),
  mutation_rate_max = 1/(Genome + 1),
  mutation_rate_min = 1/(Genome + 1),
  mutation_flag = TRUE,
  plotting = TRUE,
  verbose = TRUE,
  eval_fitness,
  eval_func_inputs
)
}
\arguments{
\item{popsize}{the number of generated solutions (population) to be evaluated at each iteration
(default is 20)}

\item{generation_max}{the number of iterations to be performed
(default is 200)}

\item{nvalues_sol}{the number of possible integer values contained in each element of the solution 
#' @param thetainit the angle (expressed in radiants) to be used when applying the rotation gate
when starting the iterations 
(default is pi * 0.05, where pi = 3.1415926535)}

\item{Genome}{the length of the genome (or chromosome), representing a possible solution}

\item{thetaend}{the angle (expressed in radiants) to be used when applying the rotation gate 
at the end of the iterations
(default is pi * 0.025, where pi = 3.1415926535)}

\item{pop_mutation_rate_max}{maximum mutation rate to be used when applying the X-Pauli gate, applied 
to each individual in the population (default is 1/(popsize+1))}

\item{pop_mutation_rate_min}{minimum mutation rate to be used when applying the X-Pauli gate, applied 
to each individual in the population (default is 1/(popsize+1))}

\item{mutation_rate_max}{maximum mutation rate to be used when applying the X-Pauli gate, applied 
to each element of the chromosome  (default is 1/(Genome+1)))}

\item{mutation_rate_min}{minimum mutation rate to be used when applying the X-Pauli gate, applied 
to each element of the chromosome (default is 1/(Genome+1))}

\item{mutation_flag}{flag indicating if the mutation gate is to be applied or not (default is TRUE)}

\item{plotting}{flag indicating plotting during iterations}

\item{verbose}{flag indicating printing fitness during iterations}

\item{eval_fitness}{name of the function that will be used to evaluate the fitness of each solution}

\item{eval_func_inputs}{specific inputs required by the eval_fitness function}
}
\value{
A numeric vector giving the best solution obtained by the QGA
}
\description{
Main function to execute a Quantum Genetic Algorithm
}
\details{
This function is the 'engine', which performs the quantum genetic algorithm calling
the function for the evaluation of the fitness that is specific for the particulare
problem to be optmized.
}
\examples{
#----------------------
library(SamplingStrata)
library(QGA)
#----------------------
# Prepare data for fitness evaluation
data(iris)
iris$id <- c(1:nrow(iris))
iris$dom <- 1
library(SamplingStrata)
frame <- buildFrameDF(
  df = iris,
  id = "id",
  domainvalue = "dom",
  X = c("id"),
  Y = c("Sepal.Length", "Sepal.Width", "Petal.Length", "Petal.Width")
)
cv <- as.data.frame(list(
  DOM = "DOM1",
  CV1 = 0.03,
  CV2 = 0.03,
  CV3 = 0.03,
  CV4 = 0.03,
  domainvalue = 1
))
nstrat = 3
#----------------------
# Set parameters
popsize = 20
generation_max = 200
nvalues_sol = nstrat
Genome = 150
thetainit = 3.1415926535 * 0.05
thetaend = 3.1415926535 * 0.025
pop_mutation_rate_max = 1/(popsize + 1)
pop_mutation_rate_min = 1/(popsize + 1)
mutation_rate_max = 1/(Genome + 1)
mutation_rate_min = 1/(Genome + 1)
mutation_flag = FALSE
eval_fitness = best_stratification
eval_func_inputs = list(frame, cv)
#----------------------
# Perform optimization
solution <- QGA(popsize,
                generation_max,
                nvalues_sol,
                Genome,
                thetainit,
                thetaend,
                pop_mutation_rate_max,
                pop_mutation_rate_min,
                mutation_rate_max,
                mutation_rate_min,
                mutation_flag,
                plotting = TRUE,
                verbose = FALSE,
                eval_fitness,
                eval_func_inputs)
#----------------------
# Analyze results
table(solution)
strata <- aggrStrata2(dataset = frame, 
                      vett = solution, 
                      dominio = 1)
sum(bethel(strata, cv, realAllocation = TRUE))
iris$stratum <- solution
table(iris$Species, iris$stratum)

}
