% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/QGA.R
\name{QGA}
\alias{QGA}
\title{Quantum Genetic Algorithm}
\usage{
QGA(
  popsize = 20,
  generation_max = 200,
  nvalues_sol,
  Genome,
  thetainit = 3.1415926535 * 0.05,
  thetaend = 3.1415926535 * 0.025,
  pop_mutation_rate_init = NULL,
  pop_mutation_rate_end = NULL,
  mutation_rate_init = NULL,
  mutation_rate_end = NULL,
  mutation_flag = TRUE,
  plotting = TRUE,
  verbose = TRUE,
  progress = TRUE,
  eval_fitness,
  eval_func_inputs,
  stop_limit = NULL,
  stop_iters = NULL
)
}
\arguments{
\item{popsize}{Integer. Population size.}

\item{generation_max}{Integer. Maximum number of generations to run.}

\item{nvalues_sol}{Integer. Number of allowed discrete values per gene (1..nvalues_sol).}

\item{Genome}{Integer. Number of genes (decision variables).}

\item{thetainit}{Numeric (radians). Initial rotation step for the update rule.}

\item{thetaend}{Numeric (radians). Final rotation step (linearly decayed to this value).}

\item{pop_mutation_rate_init}{Numeric in [0,1]. Initial per-individual mutation probability (default `1/(popsize+1)` when `mutation_flag`).}

\item{pop_mutation_rate_end}{Numeric in [0,1]. Final per-individual mutation probability (default `1/(popsize+1)` when `mutation_flag`).}

\item{mutation_rate_init}{Numeric in [0,1]. Initial per-bit mutation probability (default `1/(Genome+1)` when `mutation_flag`).}

\item{mutation_rate_end}{Numeric in [0,1]. Final per-bit mutation probability (default `1/(Genome+1)` when `mutation_flag`).}

\item{mutation_flag}{Logical. Whether to apply the mutation operator.}

\item{plotting}{Logical. If TRUE, plots fitness history over generations.}

\item{verbose}{Logical. If TRUE, prints per-generation summary to console.}

\item{progress}{Logical. If TRUE, shows a text progress bar.}

\item{eval_fitness}{Function. User-provided function with signature
`function(solution_integers, eval_func_inputs)` returning a numeric fitness value.}

\item{eval_func_inputs}{Any. Second argument passed through to `eval_fitness`.}

\item{stop_limit}{Numeric. Early-stop threshold; stops when best fitness >= `stop_limit`.}

\item{stop_iters}{Integer or NULL. If set, stops when there is no improvement
over `stop_iters` generations.}
}
\value{
A list with two elements:
- `best_solution_integers`: Integer vector of length `Genome` with values in 1..`nvalues_sol`.
- `fitness_history_df`: Data frame with columns `generation`, `fitness_average`, `fitness_best`.
}
\description{
Runs a Quantum Genetic Algorithm (QGA) to optimize a user-defined
fitness function over discrete decision variables. Internally it
initializes a quantum population, iterates measurement, rotation,
and optional mutation, repairs invalid genes, evaluates fitness in
parallel when possible, and tracks best/average fitness across generations.
}
\details{
Solutions are encoded as bitstrings and decoded to integer values in
the range 1..`nvalues_sol` for each of the `Genome` genes. The user must
supply a fitness function `eval_fitness(solution_integers, eval_func_inputs)`
that returns a numeric score to maximize.
}
\examples{
# Minimal example (toy fitness: sum of gene values)
set.seed(1)
f <- function(sol, data) sum(sol)

# This call is illustrative; tune popsize/generation_max for real problems
# out <- QGA(popsize = 10, generation_max = 5,
#            nvalues_sol = 4, Genome = 3,
#            eval_fitness = f, eval_func_inputs = NULL,
#            plotting = FALSE, verbose = FALSE, progress = FALSE)

}
\seealso{
`rotation()`, `mutation()`, `measure()`, `repair()`
}
