---
output: github_document
keep_md: TRUE
---

# QGA (Quantum Genetic Algorithm) R package

This package allows the application of the Quantum Genetic Algorithm that was first proposed by Han and Kim in 2000.

In this package, each optimization problem is represented as a maximization one, where each solution is a sequence of (qu)bits. Following the quantum paradigm, these qubits are in a superposition state: when measuring them, they collapse in a 0 or 1 state. After measurement, the fitness of the solution is calculated as in usual genetic algorithms.

The evolution at each iteration is oriented by the application of two quantum gates to the amplitudes of the qubits:

1. a rotation gate (always);
2. an X-Pauli gate (optionally).

The rotation is based on the theta angle values: higher values allow a quicker evolution, and lower values avoid local maxima.

The X-Pauli gate is equivalent to the classical mutation operator and determines the swap between alfa and beta amplitudes of a given qubit.

The package has been developed in such a way as to permit a complete separation between the "engine", and the particular problem subject to combinatorial optimization. So far, two specific problems have been implemented:

a. best stratification of a sampling frame;
b. traveler salesman problem.

In the "examples" folder, the corresponding two applications are contained. Once installed the package by executing

```{r, eval=FALSE}
devtools::install_github("d4ndo/binaryLogic")
devtools::install_github("barcaroli/QGA")
```

they can be run, and their results analyzed.

In the case of the traveler salesman problem:

```{r, eval=FALSE}
#---------------------------------------------
# Application of the Quantum Genetic Algorithm
# to the Traveler Salesman Problem
#---------------------------------------------


#----------------------
library(QGA)
#----------------------
# Prepare data for fitness evaluation
cities <- read.csv("cities.csv")
ncities <- 8
cities <- cities[c(1:ncities),]
distance <- as.matrix(dist(cities[,c(2:3)]))
#----------------------
# Set parameters
popsize = 20
generation_max = 2000
nvalues_sol = nrow(cities)
Genome = nrow(cities)
thetainit = 3.1415926535 * 0.01
thetaend = 3.1415926535 * 0.001
pop_mutation_rate_init = 1/(popsize + 1)
pop_mutation_rate_end = 1/(popsize + 1)
mutation_rate_init = 1/(Genome + 1)
mutation_rate_end = 1/(Genome + 1)
mutation_flag = FALSE
eval_fitness = TravellerSalesman
eval_func_inputs = distance
#----------------------
# Perform optimization
solution <- QGA(popsize,
                generation_max,
                nvalues_sol,
                Genome,
                thetainit,
                thetaend,
                pop_mutation_rate_init,
                pop_mutation_rate_end,
                mutation_rate_init,
                mutation_rate_end,
                mutation_flag,
                plotting = FALSE,
                verbose = FALSE,
                eval_fitness,
                eval_func_inputs)
#----------------------
# Analyze results
cities$city[solution]
cities_tsp <- cities[solution,]
plot(y~x,data=cities_tsp)
polygon(cities_tsp$x,cities_tsp$y,border="red")
text(x = cities_tsp$x, y = cities_tsp$y, labels = cities_tsp$city, cex=.75)
title("Best path")
```

In the case of the optimization of a sampling frame:

```{r, eval=FALSE}
#---------------------------------------------
# Application of the Quantum Genetic Algorithm
# to the optimization of a sampling frame
#---------------------------------------------

#----------------------
library(SamplingStrata)
library(QGA)
#----------------------
# Prepare data for fitness evaluation
data(iris)
iris$id <- c(1:nrow(iris))
iris$dom <- 1
frame <- buildFrameDF(
  df = iris,
  id = "id",
  domainvalue = "dom",
  X = c("id"),
  Y = c("Sepal.Length", "Sepal.Width", "Petal.Length", "Petal.Width")
)
cv <- as.data.frame(list(
  DOM = "DOM1",
  CV1 = 0.03,
  CV2 = 0.03,
  CV3 = 0.03,
  CV4 = 0.03,
  domainvalue = 1
))
nstrat = 3
#----------------------
# Set parameters
popsize = 20
generation_max = 500
nvalues_sol = nstrat
Genome = 150
thetainit = 3.1415926535 * 0.05
thetaend = 3.1415926535 * 0.025
pop_mutation_rate_init = 1/(popsize + 1)
pop_mutation_rate_end = 1/(popsize + 1)
mutation_rate_init = 1/(Genome + 1)
mutation_rate_end = 1/(Genome + 1)
mutation_flag = TRUE
eval_fitness = BestStratification
eval_func_inputs = list(frame, cv)
#----------------------
# Perform optimization
solution <- QGA(popsize,
                generation_max,
                nvalues_sol,
                Genome,
                thetainit,
                thetaend,
                pop_mutation_rate_init,
                pop_mutation_rate_end,
                mutation_rate_init,
                mutation_rate_end,
                mutation_flag,
                plotting = TRUE,
                verbose = FALSE,
                eval_fitness,
                eval_func_inputs)
#----------------------
# Analyze results
table(solution)
strata <- aggrStrata2(dataset = frame, 
                      vett = solution, 
                      dominio = 1)
sum(bethel(strata, cv, realAllocation = TRUE))
iris$stratum <- solution
table(iris$Species, iris$stratum)

#-------------------------------
# Comparison with SamplingStrata
sol <-optimStrata(method = "atomic",
                  framesamp = frame,
                  nStrata = nstrat,
                  errors = cv,
                  pops = popsize,
                  minnumstr = 1,
                  iter = 500)
sum(sol$aggr_strata$SOLUZ)
```



## Reference

Kuk-Hyun Han and Jong-Hwan Kim, "Genetic quantum algorithm and its application to combinatorial optimization problem," Proceedings of the 2000 Congress on Evolutionary Computation. CEC00 (Cat. No.00TH8512), 2000, pp. 1354-1360 vol.2, doi: 10.1109/CEC.2000.870809.




