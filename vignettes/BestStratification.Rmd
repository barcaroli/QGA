---
title: "Best stratification of a sampling frame"
author: "Giulio Barcaroli"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Best stratification of a sampling frame}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
  \usepackage[utf8]{inputenc}
---


```{r setup, include = FALSE}
options(width = 999)
knitr::opts_chunk$set(fig.width=8, fig.height=6,
  collapse = TRUE,
  comment = "#>")
if (!require(SamplingStrata)) install.packages("SamplingStrata")
library(SamplingStrata)
library(QGA)
load("best_stratification.Rdata")
```



Given a sampling survey, with specific precision constraints on the target estimates, the best stratification of a sampling frame is the one that ensures the minimum sample cost under the condition to satisfy those precision constraints.

In this vignette, we compare the performance of the general purpose Quantum Genetic Algorithm, versus the R package SamplingStrata, that is specialized for this task.

## Prepare the data

For this example, we make use of the "iris" dataset, that is considered as the sampling frame. A survey will make use of a sample selected from the frame, to produce estimates of the four target variables (petal length and width, sepal length and width), with a maximum allowable coefficient of variation of 3\% on these estimates.

```{r}
# Sampling frame
data(iris)
iris$id <- c(1:nrow(iris))
iris$dom <- 1
frame <- buildFrameDF(
  df = iris,
  id = "id",
  domainvalue = "dom",
  X = c("id"),
  Y = c("Sepal.Length", "Sepal.Width", "Petal.Length", "Petal.Width")
)
head(frame)
```
```{r}
# Precision constraints
cv <- as.data.frame(list(
  DOM = "DOM1",
  CV1 = 0.03,
  CV2 = 0.03,
  CV3 = 0.03,
  CV4 = 0.03,
  domainvalue = 1
))
```

Given these input data, we want to stratify the sampling frame (the "iris" dataset) obtaining 3 different optimized strata:

```{r}
nstrat = 3
```

# QGA solution 

## Fitness evaluation

The following fitness evaluation function is defined:

```{r}
BestStratification <- function(solution,
                               eval_func_inputs) {
  frame <- eval_func_inputs[[1]]
  cv <- eval_func_inputs[[2]]
  strata = SamplingStrata::aggrStrata2(dataset=frame,
                                       model=NULL,
                                       vett=solution,
                                       dominio=1)
  fitness <- -sum(SamplingStrata::bethel(strata, cv, realAllocation = TRUE))
  return(fitness)
}
```

This function receives as input parameters:

* solution (a vector that associates to each unit in the frame, the stratum it belongs to);
* the frame dataset;
* the precisione constraints.

Using the function "aggrStrata2" of SamplingStrata, the aggregate strata based on the current solution is obtained. Another SamplingStrata function ("bethel") calculates the sample size required by this solution, which the valued of the fitness.


## Optimization

We define the Genome parameter as the number of units in the frame, while the number of values to be associated to each element in the Genome is set equal to the number of desired strata (3).
This means that each solution is a vector of 150 elements, each one with an assigned value from 1 to 3: each couple element/value indicates the stratum to which the unit in the frame belongs.
In this setting, we do not want to introduce the mutation operator.
Moreover, we want to iterate 1000 times, each time considering 20 generated solutions. 

```{r, eval=FALSE}
set.seed(1234)
solutionQGA <- QGA(popsize=20,
                generation_max = 2000,
                nvalues_sol = nstrat,
                Genome = nrow(iris),
                thetainit = 3.1415926535 * 0.15,
                thetaend = 3.1415926535 * 0.0125,
                pop_mutation_rate_init = 1/(popsize + 1),
                pop_mutation_rate_end = 1/(popsize + 1),
                mutation_rate_init = 1/(Genome + 1),
                mutation_rate_end = 1/(Genome + 1),
                mutation_flag = TRUE,
                plotting = TRUE,
                verbose = FALSE,
                eval_fitness = BestStratification,
                eval_func_inputs = list(frame, cv))
```


```{r}
QGA:::plot_Output(solutionQGA[[2]])
```

The plot indicates that the number of iterations was enough to obtain a solution that is likely to be no further improved.


## Analysis of the solution


```{r}
solution_QGA <- solutionQGA[[1]]
strata <- aggrStrata2(dataset = frame, 
                      vett = solution_QGA, 
                      dominio = 1)
```
The sample size required to produce estimates compliant with the given precision constraints is: 


```{r message=F, warning=FALSE}
sum(bethel(strata, cv, realAllocation = TRUE))
```
we can compare the obtained optimal stratification with the variable "Species" in the dataset:

```{r}
iris$stratum <- solution_QGA
table(iris$Species, iris$stratum)
```
We observe that the optimized strata almost exactly replicatte the variable Species.

# SamplingStrata solution

We perform the optimization:

```{r eval=FALSE}
set.seed(1234)
solution_SamplingStrata <- optimStrata(method = "atomic",
                  framesamp = frame,
                  nStrata = nstrat,
                  errors = cv,
                  pops = popsize,
                  minnumstr = 1,
                  iter = 2000)
```


with the resulting sample size:

```{r}
sum(solution_SamplingStrata$aggr_strata$SOLUZ)
```

slightly higher than the QGA solution.

As for the optimal stratification:

```{r}
iris$stratum <- solution_SamplingStrata$framenew$LABEL
table(iris$Species, iris$stratum)
```

it is rather different from the "Species" variable. 

As a conclusion, we can say that both optimization algorithms are efficient (they yield the same sample size), but the QGA can better reproduce the "natural" stratification of the "iris" dataset.